{"version":3,"file":"9653.945ef07.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/contents/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/contents/drive.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/contents/emscripten.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/contents/drivefs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/contents/drivecontents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/kernel/base.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/kernel/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/kernel/kernelspecs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/kernel/kernelspecclient.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/kernel/client.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/nbconvert/exporters.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/nbconvert/manager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/nbconvert/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/session/client.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/services/lib/settings/settings.js"],"sourcesContent":["import { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JSON = 'application/json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n/**\n * A namespace for file constructs.\n */\nexport var FILE;\n(function (FILE) {\n    /**\n     * Build-time configured file types.\n     */\n    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');\n    /**\n     * Get a mimetype (or fallback).\n     */\n    function getType(ext, defaultType = null) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n                    return fileType.mimeTypes[0];\n                }\n            }\n        }\n        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n    }\n    FILE.getType = getType;\n    /**\n     * Determine whether the given extension matches a given fileFormat.\n     */\n    function hasFormat(ext, fileFormat) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            if (fileType.fileFormat !== fileFormat) {\n                continue;\n            }\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    FILE.hasFormat = hasFormat;\n})(FILE || (FILE = {}));\n//# sourceMappingURL=tokens.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ContentProviderRegistry, ServerConnection } from '@jupyterlab/services';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { FILE, MIME } from './tokens';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The name of the drive.\n */\nexport const DRIVE_NAME = 'BrowserStorage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n/**\n * A custom drive to store files in the browser storage.\n */\nexport class BrowserStorageDrive {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        var _a;\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._isDisposed = false;\n        this._fileChanged = new Signal(this);\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n        if (options.defaultContentProvider) {\n            this.contentProviderRegistry = new ContentProviderRegistry({\n                defaultProvider: options.defaultContentProvider,\n            });\n        }\n        else {\n            this.contentProviderRegistry = new ContentProviderRegistry();\n        }\n        this._ready = new PromiseDelegate();\n        this.initialize().catch(console.warn);\n    }\n    /**\n     * Dispose the drive.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Whether the drive is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * The name of the drive.\n     */\n    get name() {\n        return DRIVE_NAME;\n    }\n    /**\n     * The server settings of the drive.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Signal emitted when a file operation takes place.\n     */\n    get fileChanged() {\n        return this._fileChanged;\n    }\n    /**\n     * Get the download URL\n     */\n    async getDownloadUrl(path) {\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        const storage = await this.storage;\n        const localItem = (await storage.getItem(path));\n        if (localItem && localItem.content !== null) {\n            let blob;\n            if (localItem.format === 'base64') {\n                const binaryString = atob(localItem.content);\n                const bytes = new Uint8Array(binaryString.length);\n                for (let i = 0; i < binaryString.length; i++) {\n                    bytes[i] = binaryString.charCodeAt(i);\n                }\n                blob = new Blob([bytes], { type: localItem.mimetype });\n            }\n            else if (localItem.format === 'json') {\n                const content = JSON.stringify(localItem.content);\n                blob = new Blob([content], { type: localItem.mimetype });\n            }\n            else {\n                // text format\n                blob = new Blob([localItem.content], { type: localItem.mimetype });\n            }\n            return URL.createObjectURL(blob);\n        }\n        // Fall back to server URL for server files\n        const baseUrl = this.serverSettings.baseUrl;\n        const url = URLExt.join(baseUrl, 'files', URLExt.encodeParts(path));\n        return url;\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     *\n     * TODO: keep private?\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Clear all storage (files, counters, and checkpoints).\n     *\n     * @returns A promise which resolves when all storage is cleared.\n     */\n    async clearStorage() {\n        await Promise.all([\n            (await this.storage).clear(),\n            (await this.counters).clear(),\n            (await this.checkpoints).clear(),\n        ]);\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname).catch(() => null);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: 0,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: encoder.encode(JSON.stringify(Private.EMPTY_NB)).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                let ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                if (!ext.startsWith('.')) {\n                    ext = `.${ext}`;\n                }\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        this._fileChanged.emit({\n            type: 'new',\n            oldValue: null,\n            newValue: file,\n        });\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${PathExt.removeSlash(toDir)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })\n            .then(() => true)\n            .catch(() => false)) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true }).catch(() => null);\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        this._fileChanged.emit({\n            type: 'new',\n            oldValue: null,\n            newValue: item,\n        });\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        const contentProvider = this.contentProviderRegistry.getProvider(options === null || options === void 0 ? void 0 : options.contentProviderId);\n        // If a content provider is assigned, use the content provider's get\n        if (contentProvider) {\n            return contentProvider.get(path, options);\n        }\n        // Otherwise fallback to our default drive implementation\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            const folder = await this._getFolder(path);\n            if (folder === null) {\n                throw Error(`Could not find file with path ${path}`);\n            }\n            return folder;\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            throw Error(`Could not find content with path ${path}`);\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                size: 0,\n                ...model,\n                content: null,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: 0,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true }).catch(() => null);\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        this._fileChanged.emit({\n            type: 'rename',\n            oldValue: { path: oldLocalPath },\n            newValue: newFile,\n        });\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        const contentProvider = this.contentProviderRegistry.getProvider(options === null || options === void 0 ? void 0 : options.contentProviderId);\n        let item = null;\n        // If a content provider is assigned, use the content provider's save\n        if (contentProvider) {\n            item = await contentProvider.save(path, options);\n            this._fileChanged.emit({\n                type: 'save',\n                oldValue: null,\n                newValue: item,\n            });\n            return item;\n        }\n        // Otherwise fallback to our default drive implementation\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        const chunk = options.chunk;\n        // retrieve the content if it is a later chunk or the last one\n        // the new content will then be appended to the existing one\n        const appendChunk = chunk ? chunk > 1 || chunk === -1 : false;\n        item = await this.get(path, { content: appendChunk }).catch(() => null);\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        // keep a reference to the original content\n        const originalContent = item.content;\n        const modified = new Date().toISOString();\n        // override with the new values\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            const lastChunk = chunk ? chunk === -1 : true;\n            const contentBinaryString = this._handleUploadChunk(options.content, originalContent, appendChunk);\n            if (ext === '.ipynb') {\n                const content = lastChunk\n                    ? JSON.parse(decoder.decode(this._binaryStringToBytes(contentBinaryString)))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'json',\n                    type: 'notebook',\n                    size: contentBinaryString.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                const content = lastChunk\n                    ? JSON.parse(decoder.decode(this._binaryStringToBytes(contentBinaryString)))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'json',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                const content = lastChunk\n                    ? decoder.decode(this._binaryStringToBytes(contentBinaryString))\n                    : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'text',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n            else {\n                const content = lastChunk ? btoa(contentBinaryString) : contentBinaryString;\n                item = {\n                    ...item,\n                    content,\n                    format: 'base64',\n                    type: 'file',\n                    size: contentBinaryString.length,\n                };\n            }\n        }\n        // fixup content sizes if necessary\n        if (item.content) {\n            switch (options.format) {\n                case 'json': {\n                    item = { ...item, size: encoder.encode(JSON.stringify(item.content)).length };\n                    break;\n                }\n                case 'text': {\n                    item = { ...item, size: encoder.encode(item.content).length };\n                    break;\n                }\n                // base64 save was already handled above\n                case 'base64': {\n                    break;\n                }\n                default: {\n                    item = { ...item, size: 0 };\n                    break;\n                }\n            }\n        }\n        else {\n            item = { ...item, size: 0 };\n        }\n        await (await this.storage).setItem(path, item);\n        this._fileChanged.emit({\n            type: 'save',\n            oldValue: null,\n            newValue: item,\n        });\n        return item;\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n        this._fileChanged.emit({\n            type: 'delete',\n            oldValue: { path },\n            newValue: null,\n        });\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true }).catch(() => null);\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * Handle an upload chunk for a file.\n     * each chunk is base64 encoded, so we need to decode it and append it to the\n     * original content.\n     * @param newContent the new content to process, base64 encoded\n     * @param originalContent the original content, must be null or a binary string if chunked is true\n     * @param appendChunk whether the chunk should be appended to the originalContent\n     *\n     *\n     * @returns the decoded binary string, appended to the original content if requested\n     * /\n     */\n    _handleUploadChunk(newContent, originalContent, appendChunk) {\n        const newContentBinaryString = atob(newContent);\n        const contentBinaryString = appendChunk\n            ? originalContent + newContentBinaryString\n            : newContentBinaryString;\n        return contentBinaryString;\n    }\n    /**\n     * Convert a binary string to an Uint8Array\n     * @param binaryString the binary string\n     * @returns the bytes of the binary string\n     */\n    _binaryStringToBytes(binaryString) {\n        const bytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n        return bytes;\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: 0,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            size: 0,\n            content: '',\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: JSON.parse(contentText),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                        size: encoder.encode(contentText).length,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    const contentText = await response.text();\n                    model = {\n                        ...model,\n                        content: contentText,\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                        size: encoder.encode(contentText).length,\n                    };\n                }\n                else {\n                    const contentBuffer = await response.arrayBuffer();\n                    const contentBytes = new Uint8Array(contentBuffer);\n                    model = {\n                        ...model,\n                        content: btoa(contentBytes.reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                        size: contentBytes.length,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const counters = await this.counters;\n        const current = (_a = (await counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 5,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n//# sourceMappingURL=drive.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nexport const DIR_MODE = 16895; // 040777\nexport const FILE_MODE = 33206; // 100666\nexport const SEEK_CUR = 1;\nexport const SEEK_END = 2;\nexport function instanceOfStream(nodeOrStream) {\n    return 'node' in nodeOrStream;\n}\n//# sourceMappingURL=emscripten.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { UUID } from '@lumino/coreutils';\nimport { DIR_MODE, SEEK_CUR, SEEK_END, instanceOfStream } from './emscripten';\nexport const DRIVE_SEPARATOR = ':';\nexport const BLOCK_SIZE = 4096;\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n// Mapping flag -> do we need to overwrite the file upon closing it\nconst flagNeedsWrite = {\n    0 /*O_RDONLY*/: false,\n    1 /*O_WRONLY*/: true,\n    2 /*O_RDWR*/: true,\n    64 /*O_CREAT*/: true,\n    65 /*O_WRONLY|O_CREAT*/: true,\n    66 /*O_RDWR|O_CREAT*/: true,\n    129 /*O_WRONLY|O_EXCL*/: true,\n    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,\n    514 /*O_RDWR|O_TRUNC*/: true,\n    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,\n    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,\n    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,\n    1024 /*O_APPEND*/: true,\n    1025 /*O_WRONLY|O_APPEND*/: true,\n    1026 /*O_RDWR|O_APPEND*/: true,\n    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,\n    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,\n    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,\n    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,\n    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,\n    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,\n    4096 /*O_RDONLY|O_DSYNC*/: true,\n    4098 /*O_RDWR|O_DSYNC*/: true,\n};\nexport class DriveFSEmscriptenStreamOps {\n    constructor(fs) {\n        this.fs = fs;\n    }\n    open(stream) {\n        var _a;\n        const path = this.fs.realPath(stream.node);\n        if (this.fs.FS.isFile(stream.node.mode)) {\n            try {\n                const file = this.fs.API.get(path);\n                stream.file = file;\n            }\n            catch (e) {\n                // If we're opening a file for writing and the file does not exist, create it! Otherwise, throw the proper error\n                // We need to do this because the current thread is thinking a file exist (isFile returns true)\n                // whilst it was actually deleted in the main thread\n                // if writing\n                const flags = (_a = stream.flags) !== null && _a !== void 0 ? _a : stream.shared.flags;\n                let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n                parsedFlags &= 0x1fff;\n                let needsWrite = true;\n                if (parsedFlags in flagNeedsWrite) {\n                    needsWrite = flagNeedsWrite[parsedFlags];\n                }\n                if (needsWrite) {\n                    stream.node = this.fs.node_ops.mknod(stream.node.parent, stream.node.name, stream.node.mode, 0);\n                    const file = this.fs.API.get(path);\n                    stream.file = file;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['ENOENT']);\n                }\n            }\n        }\n    }\n    close(stream) {\n        var _a;\n        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {\n            return;\n        }\n        const path = this.fs.realPath(stream.node);\n        const flags = (_a = stream.flags) !== null && _a !== void 0 ? _a : stream.shared.flags;\n        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;\n        parsedFlags &= 0x1fff;\n        let needsWrite = true;\n        if (parsedFlags in flagNeedsWrite) {\n            needsWrite = flagNeedsWrite[parsedFlags];\n        }\n        if (needsWrite) {\n            this.fs.API.put(path, stream.file);\n        }\n        stream.file = undefined;\n    }\n    read(stream, buffer, offset, length, position) {\n        if (length <= 0 ||\n            stream.file === undefined ||\n            position >= (stream.file.data.length || 0)) {\n            return 0;\n        }\n        const size = Math.min(stream.file.data.length - position, length);\n        buffer.set(stream.file.data.subarray(position, position + size), offset);\n        return size;\n    }\n    write(stream, buffer, offset, length, position) {\n        var _a;\n        if (length <= 0 || stream.file === undefined) {\n            return 0;\n        }\n        const now = Date.now();\n        stream.node.timestamp = now;\n        stream.node.atime = now;\n        stream.node.mtime = now;\n        stream.node.ctime = now;\n        if (position + length > (((_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) || 0)) {\n            const oldData = stream.file.data ? stream.file.data : new Uint8Array();\n            stream.file.data = new Uint8Array(position + length);\n            stream.file.data.set(oldData);\n        }\n        stream.file.data.set(buffer.subarray(offset, offset + length), position);\n        return length;\n    }\n    llseek(stream, offset, whence) {\n        var _a;\n        let position = offset;\n        if (whence === SEEK_CUR) {\n            position += (_a = stream.position) !== null && _a !== void 0 ? _a : stream.shared.position;\n        }\n        else if (whence === SEEK_END) {\n            if (this.fs.FS.isFile(stream.node.mode)) {\n                if (stream.file !== undefined) {\n                    position += stream.file.data.length;\n                }\n                else {\n                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);\n                }\n            }\n        }\n        if (position < 0) {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);\n        }\n        return position;\n    }\n}\nexport class DriveFSEmscriptenNodeOps {\n    constructor(fs) {\n        this.node = (nodeOrStream) => {\n            if (instanceOfStream(nodeOrStream)) {\n                return nodeOrStream.node;\n            }\n            return nodeOrStream;\n        };\n        this.getattr = (value) => {\n            const node = this.node(value);\n            return {\n                ...this.fs.API.getattr(this.fs.realPath(node)),\n                mode: node.mode,\n                ino: node.id,\n            };\n        };\n        this.setattr = (value, attr) => {\n            const node = this.node(value);\n            for (const [key, value] of Object.entries(attr)) {\n                switch (key) {\n                    case 'mode':\n                        node.mode = value;\n                        break;\n                    case 'timestamp':\n                        node.timestamp = value;\n                        break;\n                    case 'atime':\n                        node.atime = value;\n                        break;\n                    case 'mtime':\n                        node.mtime = value;\n                        break;\n                    case 'ctime':\n                        node.ctime = value;\n                        break;\n                    case 'size': {\n                        const size = value;\n                        const path = this.fs.realPath(node);\n                        if (this.fs.FS.isFile(node.mode) && size >= 0) {\n                            let file;\n                            try {\n                                file = this.fs.API.get(path);\n                            }\n                            catch (e) {\n                                // TODO: Should do anything here? Should we create the file?\n                                break;\n                            }\n                            const oldData = file.data ? file.data : new Uint8Array();\n                            if (size !== oldData.length) {\n                                if (size < oldData.length) {\n                                    file.data = file.data.slice(0, size);\n                                }\n                                else {\n                                    file.data = new Uint8Array(size);\n                                    file.data.set(oldData);\n                                }\n                                this.fs.API.put(path, file);\n                            }\n                        }\n                        else {\n                            console.warn('setattr size of', size, 'on', node, 'not yet implemented');\n                        }\n                        break;\n                    }\n                    case 'dontFollow':\n                        // Ignore for now\n                        break;\n                    default:\n                        console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');\n                        break;\n                }\n            }\n        };\n        this.lookup = (parent, name) => {\n            const node = this.node(parent);\n            const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n            const result = this.fs.API.lookup(path);\n            if (!result.ok) {\n                throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['ENOENT']);\n            }\n            return this.fs.createNode(node, name, result.mode, 0);\n        };\n        this.mknod = (parent, name, mode, dev) => {\n            const node = this.node(parent);\n            const path = this.fs.PATH.join2(this.fs.realPath(node), name);\n            this.fs.API.mknod(path, mode);\n            return this.fs.createNode(node, name, mode, dev);\n        };\n        this.rename = (value, newDir, newName) => {\n            const oldNode = this.node(value);\n            const newDirNode = this.node(newDir);\n            this.fs.API.rename(oldNode.parent\n                ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)\n                : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDirNode), newName));\n            // Updating the in-memory node\n            oldNode.name = newName;\n            oldNode.parent = newDirNode;\n        };\n        this.unlink = (parent, name) => {\n            return this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n        };\n        this.rmdir = (parent, name) => {\n            return this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));\n        };\n        this.readdir = (value) => {\n            return this.fs.API.readdir(this.fs.realPath(this.node(value)));\n        };\n        this.symlink = (parent, newName, oldPath) => {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);\n        };\n        this.readlink = (node) => {\n            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EINVAL']);\n        };\n        this.fs = fs;\n    }\n}\n/**\n * ContentsAPI base class\n */\nexport class ContentsAPI {\n    constructor(options) {\n        this._driveName = options.driveName;\n        this._mountpoint = options.mountpoint;\n        this.FS = options.FS;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n    }\n    lookup(path) {\n        return this.request({ method: 'lookup', path: this.normalizePath(path) });\n    }\n    getmode(path) {\n        return this.request({ method: 'getmode', path: this.normalizePath(path) });\n    }\n    mknod(path, mode) {\n        return this.request({\n            method: 'mknod',\n            path: this.normalizePath(path),\n            data: { mode },\n        });\n    }\n    rename(oldPath, newPath) {\n        return this.request({\n            method: 'rename',\n            path: this.normalizePath(oldPath),\n            data: { newPath: this.normalizePath(newPath) },\n        });\n    }\n    readdir(path) {\n        const dirlist = this.request({\n            method: 'readdir',\n            path: this.normalizePath(path),\n        });\n        dirlist.push('.');\n        dirlist.push('..');\n        return dirlist;\n    }\n    rmdir(path) {\n        return this.request({ method: 'rmdir', path: this.normalizePath(path) });\n    }\n    get(path) {\n        const response = this.request({\n            method: 'get',\n            path: this.normalizePath(path),\n        });\n        if (!response) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n        const serializedContent = response.content;\n        const format = response.format;\n        switch (format) {\n            case 'json':\n            case 'text':\n                return {\n                    data: encoder.encode(serializedContent),\n                    format,\n                };\n            case 'base64': {\n                const binString = atob(serializedContent);\n                const len = binString.length;\n                const data = new Uint8Array(len);\n                for (let i = 0; i < len; i++) {\n                    data[i] = binString.charCodeAt(i);\n                }\n                return {\n                    data,\n                    format,\n                };\n            }\n            default:\n                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);\n        }\n    }\n    put(path, value) {\n        switch (value.format) {\n            case 'json':\n            case 'text':\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: decoder.decode(value.data),\n                    },\n                });\n            case 'base64': {\n                let binary = '';\n                for (let i = 0; i < value.data.byteLength; i++) {\n                    binary += String.fromCharCode(value.data[i]);\n                }\n                return this.request({\n                    method: 'put',\n                    path: this.normalizePath(path),\n                    data: {\n                        format: value.format,\n                        data: btoa(binary),\n                    },\n                });\n            }\n        }\n    }\n    getattr(path) {\n        const stats = this.request({\n            method: 'getattr',\n            path: this.normalizePath(path),\n        });\n        // Emscripten 4.0.9+ (used by Pyodide 0.28+) requires all three timestamps\n        // to be valid Date objects with .getTime() method (see https://github.com/emscripten-core/emscripten/pull/22998).\n        // Fallback to epoch if any timestamp is missing/null/undefined.\n        const defaultDate = new Date(0);\n        stats.atime = stats.atime ? new Date(stats.atime) : defaultDate;\n        stats.mtime = stats.mtime ? new Date(stats.mtime) : defaultDate;\n        stats.ctime = stats.ctime ? new Date(stats.ctime) : defaultDate;\n        // ensure a non-undefined size (0 isn't great, though)\n        stats.size = stats.size || 0;\n        return stats;\n    }\n    /**\n     * Normalize a Path by making it compliant for the content manager\n     *\n     * @param path: the path relatively to the Emscripten drive\n     */\n    normalizePath(path) {\n        // Remove mountpoint prefix\n        if (path.startsWith(this._mountpoint)) {\n            path = path.slice(this._mountpoint.length);\n        }\n        // Add JupyterLab drive name\n        if (this._driveName) {\n            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;\n        }\n        return path;\n    }\n}\n/**\n * An Emscripten-compatible synchronous Contents API using the service worker.\n */\nexport class ServiceWorkerContentsAPI extends ContentsAPI {\n    /**\n     * Construct a new ServiceWorkerContentsAPI.\n     */\n    constructor(options) {\n        super(options);\n        this._baseUrl = options.baseUrl;\n        this._browsingContextId = options.browsingContextId || '';\n    }\n    request(data) {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', encodeURI(this.endpoint), false);\n        // Generate unique request ID for correlation\n        const requestId = UUID.uuid4();\n        // Add the origin browsing context ID and request ID to the request\n        const requestWithMetadata = {\n            data: { ...data, requestId },\n            browsingContextId: this._browsingContextId,\n            requestId,\n        };\n        try {\n            xhr.send(JSON.stringify(requestWithMetadata));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        if (xhr.status >= 400) {\n            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        return JSON.parse(xhr.responseText);\n    }\n    /**\n     * Get the api/drive endpoint\n     */\n    get endpoint() {\n        return `${this._baseUrl}api/drive`;\n    }\n}\nexport class DriveFS {\n    constructor(options) {\n        this.FS = options.FS;\n        this.PATH = options.PATH;\n        this.ERRNO_CODES = options.ERRNO_CODES;\n        this.API = this.createAPI(options);\n        this.driveName = options.driveName;\n        this.node_ops = new DriveFSEmscriptenNodeOps(this);\n        this.stream_ops = new DriveFSEmscriptenStreamOps(this);\n    }\n    /**\n     * Create the ContentsAPI.\n     *\n     * This is supposed to be overwritten if needed.\n     */\n    createAPI(options) {\n        if (!options.browsingContextId || !options.baseUrl) {\n            throw new Error('Cannot create service-worker API without current browsingContextId');\n        }\n        return new ServiceWorkerContentsAPI(options);\n    }\n    mount(mount) {\n        return this.createNode(null, mount.mountpoint, DIR_MODE | 511, 0);\n    }\n    createNode(parent, name, mode, dev) {\n        const FS = this.FS;\n        if (!FS.isDir(mode) && !FS.isFile(mode)) {\n            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);\n        }\n        const node = FS.createNode(parent, name, mode, dev);\n        node.node_ops = this.node_ops;\n        node.stream_ops = this.stream_ops;\n        return node;\n    }\n    getMode(path) {\n        return this.API.getmode(path);\n    }\n    realPath(node) {\n        const parts = [];\n        let currentNode = node;\n        parts.push(currentNode.name);\n        while (currentNode.parent !== currentNode) {\n            currentNode = currentNode.parent;\n            parts.push(currentNode.name);\n        }\n        parts.reverse();\n        return this.PATH.join.apply(null, parts);\n    }\n}\n//# sourceMappingURL=drivefs.js.map","import { PathExt } from '@jupyterlab/coreutils';\nimport { BLOCK_SIZE } from './drivefs';\nimport { DIR_MODE, FILE_MODE } from './emscripten';\n/**\n * Class for processing a drive request from the DriveFS.\n */\nexport class DriveContentsProcessor {\n    constructor(options) {\n        this.contentsManager = options.contentsManager;\n    }\n    async processDriveRequest(request) {\n        switch (request.method) {\n            case 'readdir':\n                return this.readdir(request);\n            case 'rmdir':\n                return this.rmdir(request);\n            case 'rename':\n                return this.rename(request);\n            case 'getmode':\n                return this.getmode(request);\n            case 'lookup':\n                return this.lookup(request);\n            case 'mknod':\n                return this.mknod(request);\n            case 'getattr':\n                return this.getattr(request);\n            case 'get':\n                return this.get(request);\n            case 'put':\n                return this.put(request);\n        }\n        throw `Drive request ${request.method} does not exist.`;\n    }\n    async readdir(request) {\n        const model = await this.contentsManager.get(request.path, { content: true });\n        let response = [];\n        if (model.type === 'directory' && model.content) {\n            response = model.content.map((subcontent) => subcontent.name);\n        }\n        return response;\n    }\n    async rmdir(request) {\n        await this.contentsManager.delete(request.path);\n        return null;\n    }\n    async rename(request) {\n        await this.contentsManager.rename(request.path, request.data.newPath);\n        return null;\n    }\n    async getmode(request) {\n        const model = await this.contentsManager.get(request.path);\n        let response;\n        if (model.type === 'directory') {\n            response = DIR_MODE;\n        }\n        else {\n            response = FILE_MODE;\n        }\n        return response;\n    }\n    async lookup(request) {\n        let response;\n        try {\n            const model = await this.contentsManager.get(request.path);\n            response = {\n                ok: true,\n                mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n            };\n        }\n        catch (e) {\n            response = { ok: false };\n        }\n        return response;\n    }\n    async mknod(request) {\n        const model = await this.contentsManager.newUntitled({\n            path: PathExt.dirname(request.path),\n            type: request.data.mode === DIR_MODE ? 'directory' : 'file',\n            ext: PathExt.extname(request.path),\n        });\n        await this.contentsManager.rename(model.path, request.path);\n        return null;\n    }\n    async getattr(request) {\n        const model = await this.contentsManager.get(request.path);\n        // create a default date for drives that send incomplete information\n        // for nested foldes and files\n        const defaultDate = new Date(0).toISOString();\n        return {\n            dev: 1,\n            nlink: 1,\n            uid: 0,\n            gid: 0,\n            rdev: 0,\n            size: model.size || 0,\n            blksize: BLOCK_SIZE,\n            blocks: Math.ceil(model.size || 0 / BLOCK_SIZE),\n            atime: model.last_modified || defaultDate, // TODO Get the proper atime?\n            mtime: model.last_modified || defaultDate,\n            ctime: model.created || defaultDate,\n            timestamp: 0,\n        };\n    }\n    async get(request) {\n        let model;\n        try {\n            model = await this.contentsManager.get(request.path, { content: true });\n        }\n        catch (e) {\n            return null;\n        }\n        let response = null;\n        if (model.type !== 'directory') {\n            response = {\n                content: model.format === 'json' ? JSON.stringify(model.content) : model.content,\n                format: model.format,\n            };\n        }\n        return response;\n    }\n    async put(request) {\n        await this.contentsManager.save(request.path, {\n            content: request.data.format === 'json' && request.data.data\n                ? JSON.parse(request.data.data)\n                : request.data.data,\n            type: 'file',\n            format: request.data.format,\n        });\n        return null;\n    }\n}\n//# sourceMappingURL=drivecontents.js.map","import { KernelMessage } from '@jupyterlab/services';\nimport { Signal } from '@lumino/signaling';\n/**\n * A base kernel class handling basic kernel messaging.\n */\nexport class BaseKernel {\n    /**\n     * Construct a new BaseKernel.\n     *\n     * @param options The instantiation options for a BaseKernel.\n     */\n    constructor(options) {\n        this._history = [];\n        this._executionCount = 0;\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this._parentHeader = undefined;\n        this._parent = undefined;\n        const { id, name, location, sendMessage } = options;\n        this._id = id;\n        this._name = name;\n        this._location = location;\n        this._sendMessage = sendMessage;\n    }\n    /**\n     * A promise that is fulfilled when the kernel is ready.\n     */\n    get ready() {\n        return Promise.resolve();\n    }\n    /**\n     * Return whether the kernel is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the kernel is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Get the kernel id\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Get the name of the kernel\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * The location in the virtual filesystem from which the kernel was started.\n     */\n    get location() {\n        return this._location;\n    }\n    /**\n     * The current execution count\n     */\n    get executionCount() {\n        return this._executionCount;\n    }\n    /**\n     * Get the last parent header\n     */\n    get parentHeader() {\n        return this._parentHeader;\n    }\n    /**\n     * Get the last parent message (mimic ipykernel's get_parent)\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Dispose the kernel.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n    }\n    /**\n     * Handle an incoming message from the client.\n     *\n     * @param msg The message to handle\n     */\n    async handleMessage(msg) {\n        this._busy(msg);\n        this._parent = msg;\n        const msgType = msg.header.msg_type;\n        switch (msgType) {\n            case 'kernel_info_request':\n                await this._kernelInfo(msg);\n                break;\n            case 'execute_request':\n                await this._execute(msg);\n                break;\n            case 'input_reply':\n                this.inputReply(msg.content);\n                break;\n            case 'inspect_request':\n                await this._inspect(msg);\n                break;\n            case 'is_complete_request':\n                await this._isCompleteRequest(msg);\n                break;\n            case 'complete_request':\n                await this._complete(msg);\n                break;\n            case 'history_request':\n                await this._historyRequest(msg);\n                break;\n            case 'comm_open':\n                await this.commOpen(msg);\n                break;\n            case 'comm_msg':\n                await this.commMsg(msg);\n                break;\n            case 'comm_close':\n                await this.commClose(msg);\n                break;\n            default:\n                break;\n        }\n        this._idle(msg);\n    }\n    /**\n     * Stream an event from the kernel\n     *\n     * @param parentHeader The parent header.\n     * @param content The stream content.\n     */\n    stream(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'stream',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The display_data content.\n     */\n    displayData(content, parentHeader = undefined) {\n        var _a, _b;\n        // Make sure metadata is always set\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        content.metadata = (_a = content.metadata) !== null && _a !== void 0 ? _a : {};\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'display_data',\n            // TODO: better handle this\n            session: (_b = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _b !== void 0 ? _b : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `input_request` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The input_request content.\n     */\n    inputRequest(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'stdin',\n            msgType: 'input_request',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_result` message.\n     *\n     * @param parentHeader The parent header.\n     * @param content The execute result content.\n     */\n    publishExecuteResult(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'execute_result',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `error` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The error content.\n     */\n    publishExecuteError(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'error',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `update_display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The update_display_data content.\n     */\n    updateDisplayData(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'update_display_data',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `clear_output` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The clear_output content.\n     */\n    clearOutput(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'clear_output',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `comm` message to the client.\n     *\n     * @param .\n     */\n    handleComm(type, content, metadata, buffers, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: type,\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n            metadata,\n            buffers,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an 'idle' status message.\n     *\n     * @param parent The parent message\n     */\n    _idle(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'idle',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a 'busy' status message.\n     *\n     * @param parent The parent message.\n     */\n    _busy(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'busy',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a kernel_info_request message\n     *\n     * @param parent The parent message.\n     */\n    async _kernelInfo(parent) {\n        const content = await this.kernelInfoRequest();\n        const message = KernelMessage.createMessage({\n            msgType: 'kernel_info_reply',\n            channel: 'shell',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a `history_request` message\n     *\n     * @param msg The parent message.\n     */\n    async _historyRequest(msg) {\n        const historyMsg = msg;\n        const message = KernelMessage.createMessage({\n            msgType: 'history_reply',\n            channel: 'shell',\n            parentHeader: historyMsg.header,\n            session: msg.header.session,\n            content: {\n                status: 'ok',\n                history: this._history,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_input` message.\n     *\n     * @param msg The parent message.\n     */\n    _executeInput(msg) {\n        const parent = msg;\n        const code = parent.content.code;\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_input',\n            parentHeader: parent.header,\n            channel: 'iopub',\n            session: msg.header.session,\n            content: {\n                code,\n                execution_count: this._executionCount,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an execute_request message.\n     *\n     * @param msg The parent message.\n     */\n    async _execute(msg) {\n        const executeMsg = msg;\n        const content = executeMsg.content;\n        if (content.store_history) {\n            this._executionCount++;\n        }\n        // TODO: handle differently\n        this._parentHeader = executeMsg.header;\n        this._executeInput(executeMsg);\n        if (content.store_history) {\n            this._history.push([0, 0, content.code]);\n        }\n        const reply = await this.executeRequest(executeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_reply',\n            channel: 'shell',\n            parentHeader: executeMsg.header,\n            session: msg.header.session,\n            content: reply,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _complete(msg) {\n        const completeMsg = msg;\n        const content = await this.completeRequest(completeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'complete_reply',\n            parentHeader: completeMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an inspect_request message\n     *\n     * @param msg The parent message.\n     */\n    async _inspect(msg) {\n        const inspectMsg = msg;\n        const content = await this.inspectRequest(inspectMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'inspect_reply',\n            parentHeader: inspectMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an is_complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _isCompleteRequest(msg) {\n        const isCompleteMsg = msg;\n        const content = await this.isCompleteRequest(isCompleteMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'is_complete_reply',\n            parentHeader: isCompleteMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n}\n//# sourceMappingURL=base.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The kernel name of last resort.\n */\nexport const FALLBACK_KERNEL = 'javascript';\n/**\n * The token for the kernel client.\n */\nexport const IKernelClient = new Token('@jupyterlite/services:IKernelClient');\n/**\n * The token for the kernel spec client.\n */\nexport const IKernelSpecClient = new Token('@jupyterlite/services:IKernelSpecClient');\n/**\n * The token for the kernel spec service.\n */\nexport const IKernelSpecs = new Token('@jupyterlite/services:IKernelSpecs');\n//# sourceMappingURL=tokens.js.map","import { PageConfig } from '@jupyterlab/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { FALLBACK_KERNEL } from './tokens';\n/**\n * A class to register in-browser kernel specs.\n */\nexport class KernelSpecs {\n    constructor() {\n        this._specs = new Map();\n        this._factories = new Map();\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get the kernel specs.\n     */\n    get specs() {\n        if (this._specs.size === 0) {\n            return null;\n        }\n        return {\n            default: this.defaultKernelName,\n            kernelspecs: Object.fromEntries(this._specs),\n        };\n    }\n    /**\n     * Get the default kernel name.\n     */\n    get defaultKernelName() {\n        let defaultKernelName = PageConfig.getOption('defaultKernelName');\n        if (!defaultKernelName && this._specs.size) {\n            const keys = Array.from(this._specs.keys());\n            keys.sort();\n            defaultKernelName = keys[0];\n        }\n        return defaultKernelName || FALLBACK_KERNEL;\n    }\n    /**\n     * Get the kernel factories for the current kernels.\n     */\n    get factories() {\n        return this._factories;\n    }\n    /**\n     * Signal emitted when the specs change.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Register a new kernel.\n     *\n     * @param options The options to register a new kernel.\n     */\n    register(options) {\n        const { spec, create } = options;\n        this._specs.set(spec.name, spec);\n        this._factories.set(spec.name, create);\n        // notify a new spec has been added\n        this._changed.emit(this.specs);\n    }\n}\n//# sourceMappingURL=kernelspecs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Placeholder for the kernel specs.\n */\nconst EMPTY_KERNELSPECS = {\n    default: '',\n    kernelspecs: {},\n};\n/**\n * An in-browser client for the kernel spec API.\n */\nexport class LiteKernelSpecClient {\n    /**\n     * Construct a new kernel spec client.\n     */\n    constructor(options) {\n        var _a;\n        this._kernelspecs = options.kernelSpecs;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n    }\n    /**\n     * The server settings used by the client.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Get the kernel specs.\n     */\n    async get() {\n        var _a;\n        return Promise.resolve((_a = this._kernelspecs.specs) !== null && _a !== void 0 ? _a : EMPTY_KERNELSPECS);\n    }\n}\n//# sourceMappingURL=kernelspecclient.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ObservableMap } from '@jupyterlab/observables';\nimport { KernelAPI, KernelMessage, ServerConnection } from '@jupyterlab/services';\nimport { deserialize, serialize } from '@jupyterlab/services/lib/kernel/serialize';\nimport { supportedKernelWebSocketProtocols } from '@jupyterlab/services/lib/kernel/messages';\nimport { PromiseDelegate, UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { Mutex } from 'async-mutex';\nimport { Server as WebSocketServer } from 'mock-socket';\nimport { FALLBACK_KERNEL } from './tokens';\n/**\n * Use the default kernel wire protocol.\n */\nconst KERNEL_WEBSOCKET_PROTOCOL = supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg;\n/**\n * A class to handle requests to /api/kernels\n */\nexport class LiteKernelClient {\n    /**\n     * Construct a new Kernels\n     *\n     * @param options The instantiation options\n     */\n    constructor(options) {\n        var _a;\n        this._kernels = new ObservableMap();\n        this._clients = new ObservableMap();\n        this._mutexMap = new Map();\n        this._kernelClients = new ObservableMap();\n        this._changed = new Signal(this);\n        this._kernelSends = new ObservableMap();\n        this._cancelReason = new WeakMap();\n        const { kernelSpecs } = options;\n        this._kernelspecs = kernelSpecs;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n        // Forward the changed signal from _kernels\n        this._kernels.changed.connect((_, args) => {\n            this._changed.emit(args);\n        });\n    }\n    /**\n     * The server settings for the kernel client.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Signal emitted when the kernels map changes\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Start a new kernel.\n     *\n     * @param options The kernel start options.\n     */\n    async startNew(options) {\n        const { id, name, location } = options;\n        const kernelName = name !== null && name !== void 0 ? name : FALLBACK_KERNEL;\n        const factory = this._kernelspecs.factories.get(kernelName);\n        // bail if there is no factory associated with the requested kernel\n        if (!factory) {\n            throw Error(`No factory for kernel ${kernelName}`);\n        }\n        // create a synchronization mechanism to allow only one message\n        // to be processed at a time\n        const mutex = new Mutex();\n        // hook a new client to a kernel\n        const hook = (kernelId, clientId, socket) => {\n            var _a;\n            const kernel = this._kernels.get(kernelId);\n            if (!kernel) {\n                throw Error(`No kernel ${kernelId}`);\n            }\n            this._clients.set(clientId, socket);\n            this._mutexMap.set(kernelId, mutex);\n            (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.add(clientId);\n            const processMsg = async (msg) => {\n                try {\n                    await mutex.runExclusive(async () => {\n                        await kernel.ready;\n                        await kernel.handleMessage(msg);\n                    });\n                }\n                catch (error) {\n                    if (error instanceof Error &&\n                        error.message.includes('request for lock canceled')) {\n                        // expected to throw when mutex.cancel() is called below on cell execution error or on interrupt\n                        const cancelReason = this._cancelReason.get(mutex);\n                        if ((cancelReason === 'interrupt' ||\n                            cancelReason === 'interrupt-subsequent') &&\n                            msg.header.msg_type === 'execute_request') {\n                            if (cancelReason === 'interrupt') {\n                                // Change cancel reason so that only one cell includes the error.\n                                // Needs to go before await for mutex.\n                                this._cancelReason.set(mutex, 'interrupt-subsequent');\n                            }\n                            await mutex.waitForUnlock();\n                            // Send interrupt error to all clients\n                            const content = {\n                                status: 'error',\n                                ename: 'Kernel Interrupt',\n                                evalue: 'Interrupted',\n                                traceback: [],\n                            };\n                            const sendMessage = this._kernelSends.get(kernelId);\n                            if (sendMessage === undefined) {\n                                console.warn('Did not find kernel send method');\n                                return;\n                            }\n                            if (cancelReason === 'interrupt') {\n                                sendMessage(KernelMessage.createMessage({\n                                    channel: 'iopub',\n                                    session: clientId,\n                                    parentHeader: msg.header,\n                                    msgType: 'error',\n                                    content,\n                                }));\n                            }\n                            sendMessage(KernelMessage.createMessage({\n                                channel: 'shell',\n                                session: clientId,\n                                parentHeader: msg.header,\n                                msgType: 'execute_reply',\n                                content: {\n                                    ...content,\n                                    execution_count: 0,\n                                },\n                                metadata: {\n                                    cause: 'interrupt',\n                                },\n                            }));\n                            sendMessage(KernelMessage.createMessage({\n                                channel: 'iopub',\n                                session: clientId,\n                                parentHeader: msg.header,\n                                msgType: 'status',\n                                content: {\n                                    execution_state: 'idle',\n                                },\n                            }));\n                        }\n                    }\n                    else {\n                        throw error;\n                    }\n                }\n            };\n            socket.on('message', async (message) => {\n                let msg;\n                if (message instanceof ArrayBuffer) {\n                    message = new Uint8Array(message).buffer;\n                    msg = deserialize(message, KERNEL_WEBSOCKET_PROTOCOL);\n                }\n                else if (typeof message === 'string') {\n                    const encoder = new TextEncoder();\n                    const encodedData = encoder.encode(message);\n                    msg = deserialize(encodedData.buffer, KERNEL_WEBSOCKET_PROTOCOL);\n                }\n                else {\n                    return;\n                }\n                if (msg.header.msg_type === 'input_reply') {\n                    if (this._stdinPromise !== undefined) {\n                        // Stdin handled by Service Worker.\n                        this._stdinPromise.resolve(msg);\n                    }\n                    else {\n                        // Stdin handled by SharedArrayBuffer which is like conventional message\n                        // passing to kernel except we cannot use processMsg as the mutex is\n                        // already held.\n                        void kernel.handleMessage(msg);\n                    }\n                }\n                else {\n                    void processMsg(msg);\n                }\n            });\n            const removeClient = () => {\n                var _a;\n                this._clients.delete(clientId);\n                (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n            };\n            kernel.disposed.connect(removeClient);\n            socket.onclose = removeClient;\n        };\n        // ensure kernel id\n        const kernelId = id !== null && id !== void 0 ? id : UUID.uuid4();\n        // There is one server per kernel which handles multiple clients\n        const kernelUrl = URLExt.join(LiteKernelClient.WS_BASE_URL, KernelAPI.KERNEL_SERVICE_URL, encodeURIComponent(kernelId), 'channels');\n        const runningKernel = this._kernels.get(kernelId);\n        if (runningKernel) {\n            return {\n                id: runningKernel.id,\n                name: runningKernel.name,\n            };\n        }\n        // start the kernel\n        const sendMessage = (msg) => {\n            const clientId = msg.channel === 'stdin' ? msg.parent_header.session : msg.header.session;\n            const socket = this._clients.get(clientId);\n            if (!socket) {\n                console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);\n                return;\n            }\n            const message = serialize(msg, KERNEL_WEBSOCKET_PROTOCOL);\n            // process iopub messages\n            if (msg.channel === 'iopub') {\n                const clients = this._kernelClients.get(kernelId);\n                clients === null || clients === void 0 ? void 0 : clients.forEach((id) => {\n                    var _a;\n                    (_a = this._clients.get(id)) === null || _a === void 0 ? void 0 : _a.send(message);\n                });\n                return;\n            }\n            // cancel the execution of other cells if there is an execute error\n            // to match the JupyterLab behavior\n            if (msg.header.msg_type === 'execute_reply') {\n                const executeReplyMsg = msg;\n                if (executeReplyMsg.content.status === 'error' &&\n                    executeReplyMsg.metadata.cause !== 'interrupt') {\n                    this._cancelReason.set(mutex, 'error');\n                    mutex.cancel();\n                }\n            }\n            socket.send(message);\n        };\n        const kernel = await factory({\n            id: kernelId,\n            sendMessage,\n            name: kernelName,\n            location: location !== null && location !== void 0 ? location : '',\n        });\n        this._kernels.set(kernelId, kernel);\n        this._kernelClients.set(kernelId, new Set());\n        this._kernelSends.set(kernelId, sendMessage);\n        // create the websocket server for the kernel\n        const wsServer = new WebSocketServer(kernelUrl, {\n            mock: false,\n            selectProtocol: () => KERNEL_WEBSOCKET_PROTOCOL,\n        });\n        wsServer.on('connection', (socket) => {\n            var _a;\n            const url = new URL(socket.url);\n            const clientId = (_a = url.searchParams.get('session_id')) !== null && _a !== void 0 ? _a : '';\n            hook(kernelId, clientId, socket);\n        });\n        // clean up closed connection\n        wsServer.on('close', () => {\n            this._clients.keys().forEach((clientId) => {\n                var _a;\n                const socket = this._clients.get(clientId);\n                if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.CLOSED) {\n                    this._clients.delete(clientId);\n                    (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n                }\n            });\n        });\n        // cleanup on kernel shutdown\n        kernel.disposed.connect(() => {\n            wsServer.close();\n            this._kernels.delete(kernelId);\n            this._kernelClients.delete(kernelId);\n            this._mutexMap.delete(kernelId);\n            this._kernelSends.delete(kernelId);\n        });\n        return {\n            id: kernel.id,\n            name: kernel.name,\n        };\n    }\n    /**\n     * Restart a kernel.\n     *\n     * @param kernelId The kernel id.\n     */\n    async restart(kernelId) {\n        const kernel = this._kernels.get(kernelId);\n        if (!kernel) {\n            throw Error(`Kernel ${kernelId} does not exist`);\n        }\n        const { id, name, location } = kernel;\n        kernel.dispose();\n        await this.startNew({ id, name, location });\n    }\n    /**\n     * Interrupt a kernel.\n     */\n    async interrupt(kernelId) {\n        const kernel = this._kernels.get(kernelId);\n        if (!kernel) {\n            throw Error(`Kernel ${kernelId} does not exist`);\n        }\n        // Wait for kernel to be ready\n        await kernel.ready;\n        // Cancel execution of following cells\n        const mutex = this._mutexMap.get(kernelId);\n        if (!mutex) {\n            console.warn('No mutex to cancel');\n            return;\n        }\n        this._cancelReason.set(mutex, 'interrupt');\n        mutex.cancel();\n    }\n    /**\n     * List the running kernels.\n     */\n    async listRunning() {\n        return [...this._kernels.values()].map((kernel) => ({\n            id: kernel.id,\n            name: kernel.name,\n        }));\n    }\n    /**\n     * Shut down a kernel.\n     *\n     * @param id The kernel id.\n     */\n    async shutdown(id) {\n        var _a;\n        (_a = this._kernels.delete(id)) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._kernelClients.delete(id);\n        this._kernelSends.delete(id);\n    }\n    /**\n     * Shut down all kernels.\n     */\n    async shutdownAll() {\n        this._kernels.keys().forEach((id) => {\n            this.shutdown(id);\n        });\n    }\n    /**\n     * Get a kernel by id\n     */\n    async getModel(id) {\n        return this._kernels.get(id);\n    }\n    /**\n     * Handle stdin request received from Service Worker.\n     */\n    async handleStdin(inputRequest) {\n        this._stdinPromise = new PromiseDelegate();\n        const clientId = inputRequest.parent_header.session;\n        const kernelId = this._getClientKernel(clientId);\n        if (kernelId !== undefined) {\n            const sendMessage = this._kernelSends.get(kernelId);\n            if (sendMessage !== undefined) {\n                sendMessage(inputRequest);\n            }\n        }\n        // Promise is resolved by input reply message.\n        return this._stdinPromise.promise;\n    }\n    /**\n     * Get a kernel id corresponding to a client id.\n     */\n    _getClientKernel(clientId) {\n        // Walk the _kernelClients to find a match.\n        return this._kernelClients\n            .keys()\n            .find((kernelId) => this._kernelClients.get(kernelId).has(clientId));\n    }\n}\n/**\n * A namespace for Kernels statics.\n */\n(function (LiteKernelClient) {\n    /**\n     * The base url for the Kernels manager\n     */\n    LiteKernelClient.WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');\n})(LiteKernelClient || (LiteKernelClient = {}));\n//# sourceMappingURL=client.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * Base class for notebook exporters.\n */\nexport class BaseExporter {\n    /**\n     * Trigger a browser download of the exported content.\n     *\n     * @param content The content to download\n     * @param mimeType The MIME type of the content\n     * @param filename The filename for the download\n     */\n    triggerDownload(content, mimeType, filename) {\n        const element = document.createElement('a');\n        element.href = `data:${mimeType};charset=utf-8,${encodeURIComponent(content)}`;\n        element.download = filename;\n        document.body.appendChild(element);\n        element.click();\n        document.body.removeChild(element);\n    }\n}\n/**\n * Exporter for notebook format (.ipynb).\n */\nexport class NotebookExporter extends BaseExporter {\n    constructor() {\n        super(...arguments);\n        /**\n         * The MIME type of the exported format.\n         */\n        this.mimeType = 'application/x-ipynb+json';\n    }\n    /**\n     * Export a notebook to .ipynb format.\n     *\n     * @param model The notebook model to export\n     * @param path The path to the notebook\n     */\n    async export(model, path) {\n        var _a;\n        const mime = (_a = model.mimetype) !== null && _a !== void 0 ? _a : 'application/json';\n        const content = JSON.stringify(model.content, null, 2);\n        this.triggerDownload(content, mime, path);\n    }\n}\n/**\n * Exporter for executable script format.\n */\nexport class ScriptExporter extends BaseExporter {\n    constructor() {\n        super(...arguments);\n        /**\n         * The MIME type of the exported format.\n         */\n        this.mimeType = 'text/x-script';\n    }\n    /**\n     * Export a notebook to executable script format.\n     *\n     * @param model The notebook model to export\n     * @param path The path to the notebook\n     */\n    async export(model, path) {\n        const { content, extension } = this.convertToScript(model.content);\n        const filename = path.replace(/\\.ipynb$/, extension);\n        this.triggerDownload(content, 'text/plain', filename);\n    }\n    /**\n     * Convert a notebook to a script file.\n     *\n     * @param content The notebook content\n     * @returns The script content and file extension\n     */\n    convertToScript(content) {\n        var _a;\n        // Get the language from the notebook metadata\n        const languageInfo = (_a = content.metadata) === null || _a === void 0 ? void 0 : _a.language_info;\n        const language = (languageInfo === null || languageInfo === void 0 ? void 0 : languageInfo.name) || 'python';\n        const fileExtension = (languageInfo === null || languageInfo === void 0 ? void 0 : languageInfo.file_extension) || '.py';\n        // Extract code cells and convert to script\n        const cells = content.cells || [];\n        const scriptLines = [];\n        for (const cell of cells) {\n            if (cell.cell_type === 'code') {\n                // Add code cell content\n                const source = Array.isArray(cell.source) ? cell.source.join('') : cell.source;\n                scriptLines.push(source);\n                // Add blank line between cells\n                scriptLines.push('');\n            }\n            else if (cell.cell_type === 'markdown' || cell.cell_type === 'raw') {\n                // Add markdown and raw cells as comments\n                const source = Array.isArray(cell.source) ? cell.source.join('') : cell.source;\n                const commentedSource = this.commentLines(source, language);\n                scriptLines.push(commentedSource);\n                // Add blank line between cells\n                scriptLines.push('');\n            }\n        }\n        return {\n            content: scriptLines.join('\\n') + '\\n',\n            extension: fileExtension,\n        };\n    }\n    /**\n     * Comment out lines based on the language.\n     *\n     * @param text The text to comment\n     * @param language The programming language\n     * @returns The commented text\n     */\n    commentLines(text, language) {\n        const lines = text.split('\\n');\n        const commentChar = this.getCommentChar(language);\n        return lines.map((line) => `${commentChar} ${line}`).join('\\n');\n    }\n    /**\n     * Get the comment character for a given language.\n     *\n     * @param language The programming language\n     * @returns The comment character(s) for that language\n     */\n    getCommentChar(language) {\n        // Map of languages to their comment characters\n        const commentMap = {\n            python: '#',\n            r: '#',\n            julia: '#',\n            ruby: '#',\n            bash: '#',\n            shell: '#',\n            perl: '#',\n            javascript: '//',\n            typescript: '//',\n            java: '//',\n            c: '//',\n            cpp: '//',\n            'c++': '//',\n            scala: '//',\n            go: '//',\n            rust: '//',\n            swift: '//',\n            kotlin: '//',\n            matlab: '%',\n            octave: '%',\n            lua: '--',\n            sql: '--',\n            haskell: '--',\n        };\n        return commentMap[language.toLowerCase()] || '#';\n    }\n}\n//# sourceMappingURL=exporters.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NbConvertManager } from '@jupyterlab/services';\n/**\n * Custom NbConvert manager for JupyterLite with client-side export.\n */\nexport class LiteNbConvertManager extends NbConvertManager {\n    /**\n     * Construct a new LiteNbConvertManager.\n     *\n     * @param options The manager options\n     */\n    constructor(options) {\n        super(options);\n        this._contentsManager = options.contentsManager;\n        this._exporters = options.exporters;\n    }\n    /**\n     * Get the list of export formats available.\n     */\n    async getExportFormats() {\n        return this._exporters.getExportFormats();\n    }\n    /**\n     * Export a notebook to a given format.\n     *\n     * @param options The export options\n     */\n    async exportAs(options) {\n        const { format, path } = options;\n        const model = await this._contentsManager.get(path, { content: true });\n        const exporter = this._exporters.get(format);\n        if (!exporter) {\n            throw new Error(`Unknown export format: ${format}`);\n        }\n        await exporter.export(model, path);\n    }\n}\n/**\n * Implementation of the exporter registry.\n */\nexport class Exporters {\n    constructor() {\n        this._exporters = new Map();\n    }\n    /**\n     * Register a new exporter.\n     *\n     * @param format The export format name\n     * @param exporter The exporter instance\n     */\n    register(format, exporter) {\n        this._exporters.set(format, exporter);\n    }\n    /**\n     * Get an exporter by format.\n     *\n     * @param format The export format name\n     * @returns The exporter or undefined if not found\n     */\n    get(format) {\n        return this._exporters.get(format);\n    }\n    /**\n     * Get all registered export formats.\n     *\n     * @returns A map of format names to their MIME types\n     */\n    getExportFormats() {\n        const formats = {};\n        for (const [format, exporter] of this._exporters) {\n            formats[format] = { output_mimetype: exporter.mimeType };\n        }\n        return formats;\n    }\n}\n//# sourceMappingURL=manager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the exporter registry.\n */\nexport const INbConvertExporters = new Token('@jupyterlite/services:INbConvertExporters', 'A service for managing notebook exporters in JupyterLite');\n//# sourceMappingURL=tokens.js.map","import { ServerConnection } from '@jupyterlab/services';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { UUID } from '@lumino/coreutils';\n/**\n * A class to handle requests to /api/sessions\n */\nexport class LiteSessionClient {\n    /**\n     * Construct a new LiteSessionClient.\n     *\n     * @param options The instantiation options for a LiteSessionClient.\n     */\n    constructor(options) {\n        var _a;\n        this._sessions = [];\n        this._pendingRestarts = new Set();\n        this._kernelClient = options.kernelClient;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n        // Listen for kernel removals\n        this._kernelClient.changed.connect((_, args) => {\n            var _a, _b;\n            switch (args.type) {\n                case 'remove': {\n                    const kernelId = (_a = args.oldValue) === null || _a === void 0 ? void 0 : _a.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    // find the session associated with the kernel\n                    const session = this._sessions.find((s) => { var _a; return ((_a = s.kernel) === null || _a === void 0 ? void 0 : _a.id) === kernelId; });\n                    if (!session) {\n                        return;\n                    }\n                    // Track the kernel ID for restart detection\n                    this._pendingRestarts.add(kernelId);\n                    setTimeout(async () => {\n                        // If after a short delay the kernel hasn't been re-added, it was terminated\n                        if (this._pendingRestarts.has(kernelId)) {\n                            this._pendingRestarts.delete(kernelId);\n                            await this.shutdown(session.id);\n                        }\n                    }, 100);\n                    break;\n                }\n                case 'add': {\n                    // If this was a restart, remove it from pending\n                    const kernelId = (_b = args.newValue) === null || _b === void 0 ? void 0 : _b.id;\n                    if (!kernelId) {\n                        return;\n                    }\n                    this._pendingRestarts.delete(kernelId);\n                    break;\n                }\n            }\n        });\n    }\n    /**\n     * The server settings for the session client.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Get a session by id.\n     *\n     * @param id The id of the session.\n     */\n    async getModel(id) {\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        return session;\n    }\n    /**\n     * List the running sessions\n     */\n    async listRunning() {\n        return this._sessions;\n    }\n    /**\n     * Patch an existing session.\n     * This can be used to rename a session.\n     *\n     * - path updates session to track renamed paths\n     * - kernel.name starts a new kernel with a given kernelspec\n     *\n     * @param options The options to patch the session.\n     */\n    async update(options) {\n        const { id, path, name, kernel } = options;\n        const index = this._sessions.findIndex((s) => s.id === id);\n        const session = this._sessions[index];\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const patched = {\n            ...session,\n            path: path !== null && path !== void 0 ? path : session.path,\n            name: name !== null && name !== void 0 ? name : session.name,\n        };\n        if (kernel) {\n            // Kernel id takes precedence over name.\n            if (kernel.id) {\n                const session = this._sessions.find((session) => { var _a; return ((_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id) === (kernel === null || kernel === void 0 ? void 0 : kernel.id); });\n                if (session) {\n                    patched.kernel = session.kernel;\n                }\n            }\n            else if (kernel.name) {\n                const newKernel = await this._kernelClient.startNew({\n                    id: UUID.uuid4(),\n                    name: kernel.name,\n                    location: PathExt.dirname(patched.path),\n                });\n                if (newKernel) {\n                    patched.kernel = newKernel;\n                }\n                // clean up the session on kernel shutdown\n                void this._handleKernelShutdown({\n                    kernelId: newKernel.id,\n                    sessionId: session.id,\n                });\n            }\n        }\n        this._sessions[index] = patched;\n        return patched;\n    }\n    /**\n     * Start a new session\n     * TODO: read path and name\n     *\n     * @param options The options to start a new session.\n     */\n    async startNew(options) {\n        var _a, _b, _c;\n        const { path, name } = options;\n        const running = this._sessions.find((s) => s.name === name);\n        if (running) {\n            return running;\n        }\n        const kernelName = (_b = (_a = options.kernel) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : '';\n        const id = UUID.uuid4();\n        const nameOrPath = (_c = options.name) !== null && _c !== void 0 ? _c : options.path;\n        const dirname = PathExt.dirname(options.name) || PathExt.dirname(options.path);\n        const hasDrive = nameOrPath.includes(':');\n        const driveName = hasDrive ? nameOrPath.split(':')[0] : '';\n        // add drive name if missing (top level directory)\n        const location = dirname.includes(driveName) ? dirname : `${driveName}:${dirname}`;\n        const kernel = await this._kernelClient.startNew({\n            id,\n            name: kernelName,\n            location,\n        });\n        const session = {\n            id,\n            path,\n            name: name !== null && name !== void 0 ? name : path,\n            type: 'notebook',\n            kernel: {\n                id: kernel.id,\n                name: kernel.name,\n            },\n        };\n        this._sessions.push(session);\n        // clean up the session on kernel shutdown\n        void this._handleKernelShutdown({ kernelId: id, sessionId: session.id });\n        return session;\n    }\n    /**\n     * Shut down a session.\n     *\n     * @param id The id of the session to shut down.\n     */\n    async shutdown(id) {\n        var _a;\n        const session = this._sessions.find((s) => s.id === id);\n        if (!session) {\n            throw Error(`Session ${id} not found`);\n        }\n        const kernelId = (_a = session.kernel) === null || _a === void 0 ? void 0 : _a.id;\n        if (kernelId) {\n            await this._kernelClient.shutdown(kernelId);\n        }\n        ArrayExt.removeFirstOf(this._sessions, session);\n    }\n    /**\n     * Shut down all sessions.\n     */\n    async shutdownAll() {\n        await Promise.all(this._sessions.map((s) => this.shutdown(s.id)));\n    }\n    /**\n     * Handle kernel shutdown\n     */\n    async _handleKernelShutdown({ kernelId, sessionId, }) {\n        // No need to handle kernel shutdown here anymore since we're using the changed signal\n    }\n}\n//# sourceMappingURL=client.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { SettingManager } from '@jupyterlab/services';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport * as json5 from 'json5';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * A class to manage settings in the browser.\n */\nexport class Settings extends SettingManager {\n    /**\n     * Create a new settings service.\n     */\n    constructor(options) {\n        super({\n            serverSettings: options.serverSettings,\n        });\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n        void this.initialize().catch(console.warn);\n    }\n    /**\n     * A promise that resolves when the settings storage is fully initialized\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to initialized storage\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Prepare the storage\n     */\n    async initStorage() {\n        this._storage = this.defaultSettingsStorage();\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        var _a;\n        const driver = ((_a = this._storageDrivers) === null || _a === void 0 ? void 0 : _a.length) ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Create a settings store.\n     */\n    defaultSettingsStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Settings',\n            storeName: 'settings',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Get settings by plugin id\n     *\n     * @param pluginId the id of the plugin\n     *\n     */\n    async fetch(pluginId) {\n        const all = await this.list();\n        const settings = all.values;\n        const setting = settings.find((setting) => {\n            return setting.id === pluginId;\n        });\n        if (!setting) {\n            throw new Error(`Setting ${pluginId} not found`);\n        }\n        return setting;\n    }\n    /**\n     * Get all the settings\n     */\n    async list(query) {\n        var _a, _b;\n        const allCore = await this._getAll('all.json');\n        let allFederated = [];\n        try {\n            allFederated = await this._getAll('all_federated.json');\n        }\n        catch {\n            // handle the case where there is no federated extension\n        }\n        // JupyterLab 4 expects all settings to be returned in one go\n        // so append the settings from federated plugins to the core ones\n        const all = allCore.concat(allFederated);\n        // return existing user settings if they exist\n        const storage = await this.storage;\n        const settings = await Promise.all(all.map(async (plugin) => {\n            var _a;\n            const { id } = plugin;\n            const raw = (_a = (await storage.getItem(id))) !== null && _a !== void 0 ? _a : plugin.raw;\n            return {\n                ...Private.override(plugin),\n                raw,\n                settings: json5.parse(raw),\n            };\n        }));\n        // format the settings\n        const ids = (_a = settings.map((plugin) => plugin.id)) !== null && _a !== void 0 ? _a : [];\n        let values = [];\n        if (!query) {\n            values =\n                (_b = settings.map((plugin) => {\n                    plugin.data = { composite: {}, user: {} };\n                    return plugin;\n                })) !== null && _b !== void 0 ? _b : [];\n        }\n        return { ids, values };\n    }\n    /**\n     * Save settings for a given plugin id\n     *\n     * @param pluginId The id of the plugin\n     * @param raw The raw settings\n     *\n     */\n    async save(id, raw) {\n        await (await this.storage).setItem(id, raw);\n    }\n    /**\n     * Clear all stored settings\n     *\n     * @returns A promise which resolves when the settings are cleared\n     */\n    async clear() {\n        await (await this.storage).clear();\n    }\n    /**\n     * Get all the settings for core or federated plugins\n     */\n    async _getAll(file) {\n        var _a;\n        const settingsUrl = (_a = PageConfig.getOption('settingsUrl')) !== null && _a !== void 0 ? _a : '/';\n        const all = (await (await fetch(URLExt.join(settingsUrl, file))).json());\n        return all;\n    }\n}\n/**\n * A namespace for private data\n */\nvar Private;\n(function (Private) {\n    const _overrides = JSON.parse(PageConfig.getOption('settingsOverrides') || '{}');\n    /**\n     * Override the defaults of the schema with ones from PageConfig\n     *\n     * @see https://github.com/jupyterlab/jupyterlab_server/blob/v2.5.2/jupyterlab_server/settings_handler.py#L216-L227\n     */\n    function override(plugin) {\n        if (_overrides[plugin.id]) {\n            if (!plugin.schema.properties) {\n                // probably malformed, or only provides keyboard shortcuts, etc.\n                plugin.schema.properties = {};\n            }\n            for (const [prop, propDefault] of Object.entries(_overrides[plugin.id] || {})) {\n                plugin.schema.properties[prop].default = propDefault;\n            }\n        }\n        return plugin;\n    }\n    Private.override = override;\n})(Private || (Private = {}));\n//# sourceMappingURL=settings.js.map"],"names":["MIME","FILE","JSON","PLAIN_TEXT","OCTET_STREAM","TYPES","parse","PageConfig","getOption","getType","ext","defaultType","toLowerCase","fileType","Object","values","fileExt","extensions","mimeTypes","length","hasFormat","fileFormat","DEFAULT_STORAGE_NAME","DRIVE_NAME","encoder","TextEncoder","decoder","TextDecoder","BrowserStorageDrive","constructor","options","_a","this","reduceBytesToString","data","byte","String","fromCharCode","_serverContents","Map","_isDisposed","_fileChanged","Signal","_storageName","_storageDrivers","_localforage","localforage","storageName","storageDrivers","_serverSettings","serverSettings","ServerConnection","makeSettings","defaultContentProvider","contentProviderRegistry","ContentProviderRegistry","defaultProvider","_ready","PromiseDelegate","initialize","catch","console","warn","dispose","isDisposed","clearData","name","fileChanged","getDownloadUrl","path","decodeURIComponent","replace","storage","localItem","getItem","content","blob","format","binaryString","atob","bytes","Uint8Array","i","charCodeAt","Blob","type","mimetype","stringify","URL","createObjectURL","baseUrl","URLExt","join","encodeParts","initStorage","resolve","_storage","createDefaultStorage","_counters","createDefaultCounters","_checkpoints","createDefaultCheckpoints","ready","promise","then","counters","checkpoints","defaultStorageOptions","driver","version","createInstance","description","storeName","clearStorage","Promise","all","clear","newUntitled","_b","_c","created","Date","toISOString","dirname","PathExt","basename","extname","item","get","file","_incrementCounter","last_modified","size","writable","counter","Private","EMPTY_NB","encode","startsWith","indexOf","key","setItem","emit","oldValue","newValue","copy","toDir","removeSlash","base","toPath","Error","contentProvider","getProvider","contentProviderId","folder","_getFolder","serverItem","_getServerContents","model","contentMap","iterate","set","serverContents","Array","from","_getServerDirectory","has","rename","oldLocalPath","newLocalPath","modified","newFile","removeItem","child","save","chunk","appendChunk","originalContent","lastChunk","contentBinaryString","_handleUploadChunk","decode","_binaryStringToBytes","btoa","slashed","toDelete","keys","filter","map","forgetPath","createCheckpoint","copies","Boolean","push","splice","id","listCheckpoints","normalizeCheckpoint","toString","restoreCheckpoint","checkpointID","parseInt","deleteCheckpoint","newContent","newContentBinaryString","includes","fileUrl","getBaseUrl","response","fetch","ok","headers","match","contentText","text","contentBuffer","arrayBuffer","contentBytes","reduce","apiURL","json","err","metadata","orig_nbformat","nbformat_minor","nbformat","cells","DIR_MODE","FILE_MODE","SEEK_CUR","SEEK_END","instanceOfStream","nodeOrStream","DRIVE_SEPARATOR","BLOCK_SIZE","flagNeedsWrite","DriveFSEmscriptenStreamOps","fs","open","stream","realPath","node","FS","isFile","mode","API","e","flags","shared","parsedFlags","needsWrite","ErrnoError","ERRNO_CODES","node_ops","mknod","parent","close","put","undefined","read","buffer","offset","position","Math","min","subarray","write","now","timestamp","atime","mtime","ctime","oldData","llseek","whence","EPERM","EINVAL","DriveFSEmscriptenNodeOps","getattr","value","ino","setattr","attr","entries","slice","lookup","PATH","join2","result","createNode","dev","newDir","newName","oldNode","newDirNode","unlink","rmdir","readdir","symlink","oldPath","readlink","ContentsAPI","_driveName","driveName","_mountpoint","mountpoint","request","method","normalizePath","getmode","newPath","dirlist","serializedContent","binString","len","binary","byteLength","stats","defaultDate","ServiceWorkerContentsAPI","super","_baseUrl","_browsingContextId","browsingContextId","xhr","XMLHttpRequest","encodeURI","endpoint","requestId","UUID","uuid4","requestWithMetadata","send","error","status","responseText","DriveFS","createAPI","stream_ops","mount","isDir","getMode","parts","currentNode","reverse","apply","DriveContentsProcessor","contentsManager","processDriveRequest","subcontent","delete","nlink","uid","gid","rdev","blksize","blocks","ceil","BaseKernel","_history","_executionCount","_disposed","_parentHeader","_parent","location","sendMessage","_id","_name","_location","_sendMessage","disposed","executionCount","parentHeader","handleMessage","msg","_busy","header","msg_type","_kernelInfo","_execute","inputReply","_inspect","_isCompleteRequest","_complete","_historyRequest","commOpen","commMsg","commClose","_idle","parentHeaderValue","message","KernelMessage","createMessage","channel","msgType","session","displayData","inputRequest","publishExecuteResult","publishExecuteError","updateDisplayData","clearOutput","handleComm","buffers","execution_state","kernelInfoRequest","historyMsg","history","_executeInput","code","execution_count","executeMsg","store_history","reply","executeRequest","completeMsg","completeRequest","inspectMsg","inspectRequest","isCompleteMsg","isCompleteRequest","FALLBACK_KERNEL","IKernelClient","Token","IKernelSpecClient","IKernelSpecs","KernelSpecs","_specs","_factories","_changed","specs","default","defaultKernelName","kernelspecs","fromEntries","sort","factories","changed","register","spec","create","EMPTY_KERNELSPECS","LiteKernelSpecClient","_kernelspecs","kernelSpecs","KERNEL_WEBSOCKET_PROTOCOL","supportedKernelWebSocketProtocols","v1KernelWebsocketJupyterOrg","LiteKernelClient","_kernels","ObservableMap","_clients","_mutexMap","_kernelClients","_kernelSends","_cancelReason","WeakMap","connect","_","args","startNew","kernelName","factory","mutex","hook","kernelId","clientId","socket","kernel","add","processMsg","async","runExclusive","cancelReason","waitForUnlock","ename","evalue","traceback","cause","on","ArrayBuffer","deserialize","encodedData","_stdinPromise","removeClient","onclose","kernelUrl","WS_BASE_URL","KernelAPI","KERNEL_SERVICE_URL","encodeURIComponent","runningKernel","parent_header","serialize","executeReplyMsg","cancel","clients","forEach","Set","wsServer","mock","selectProtocol","url","searchParams","readyState","WebSocket","CLOSED","restart","interrupt","listRunning","shutdown","shutdownAll","getModel","handleStdin","_getClientKernel","find","BaseExporter","triggerDownload","mimeType","filename","element","document","createElement","href","download","body","appendChild","click","removeChild","NotebookExporter","arguments","mime","ScriptExporter","extension","convertToScript","languageInfo","language_info","language","fileExtension","file_extension","scriptLines","cell","cell_type","source","isArray","commentedSource","commentLines","lines","split","commentChar","getCommentChar","line","python","r","julia","ruby","bash","shell","perl","javascript","typescript","java","c","cpp","scala","go","rust","swift","kotlin","matlab","octave","lua","sql","haskell","LiteNbConvertManager","NbConvertManager","_contentsManager","_exporters","exporters","getExportFormats","exportAs","exporter","export","Exporters","formats","output_mimetype","INbConvertExporters","LiteSessionClient","_sessions","_pendingRestarts","_kernelClient","kernelClient","s","setTimeout","update","index","findIndex","patched","newKernel","_handleKernelShutdown","sessionId","running","nameOrPath","ArrayExt","removeFirstOf","Settings","SettingManager","defaultSettingsStorage","pluginId","setting","list","query","allCore","_getAll","allFederated","concat","settings","plugin","raw","override","ids","composite","user","settingsUrl","_overrides","schema","properties","prop","propDefault"],"sourceRoot":""}